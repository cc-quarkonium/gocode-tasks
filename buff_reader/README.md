Нам нужно передать данные от некоторого источника (`Producer`) некоторому потребителю (`Consumer`).\
При этом источник отдает данные небольшими пачками (например, десятки записей), а потребитель оптимальнее работает с крупными батчами (например, тысячи записей).

Интерфейс источника 
```go
type Producer interface {
	// Next возвращает:
	// itmes - батч элементов, которые необходимо обратотать
	// cookie - значение, которым впоследствии необходимо подтвердить обработку вызовом Commit
	// error - ошибка, в том числе ошибку, сигнализирущая об отсутствии следующий данных
	Next() (items []any, cookie int, err error)
	// Commit - ф-я для подтверждения обработки данных потребителем
	Commit(cookie int) error
}
```

Интерфейс приемника:
```go
type Consumer interface {
	Process(items []any) error
}
```
Сигнатура функции, которую необходимо реализовать:
```go
func Pipe(config *Congif, producer Producer, consumer Consumer) error {
	// TODO
}
```

Требования и ограничения:
- При возникновении ошибок программе можно выйти без дообработки.
- Источник:
    - Источник никогда не возвращает более `MaxItems` записей за один вызов `Next`.
    - В рамках одной "сессии" (одного вызова функции `Pipe`) источник каждый раз возвращает новые данные на каждый вызов `Next`.
    - **Каждое** значение `cookie`, которое вернул вызов `Next`, после сохранения данных в приемнике,
        должно быть фиксировано вызовом `Commit`, причем строго в той же последовательности, в которой их вернул `Next`.
    - Если данные в источнике закончились, то `Next` возвращает ошибку `ErrEofCommitCookie`

- Приемник:
    - Не может обработать более `MaxItems` за один раз.

Усложнения:
- Осуществлять вызовы параллельно/конкурентно, где это возможно (не забывай про строго последовательный Commit).
